<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dea_ml.core.predict_from_feature API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dea_ml.core.predict_from_feature</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import json
import logging
import math
import os
import os.path as osp
import uuid
from typing import Optional, Dict

import numpy as np
import psutil
import xarray as xr
from datacube.utils.cog import write_cog
from datacube.utils.dask import start_local_dask
from datacube.utils.geometry import GeoBox
from datacube.utils.rio import configure_s3_access
from distributed import Client
from odc.io.cgroups import get_cpu_quota, get_mem_quota
from odc.stats._cli_common import setup_logging

from dea_ml.config.product_feature_config import FeaturePathConfig
from dea_ml.core.cm_prediction import predict_xr
from dea_ml.core.feature_layer import get_xy_from_task
from dea_ml.core.stac_to_dc import StacIntoDc
from dea_ml.helpers.io import prepare_the_io_path


def get_max_mem() -&gt; int:
    &#34;&#34;&#34;
    Max available memory, takes into account pod resource allocation
    &#34;&#34;&#34;
    total = psutil.virtual_memory().total
    mem_quota = get_mem_quota()
    if mem_quota is None:
        return total
    return min(mem_quota, total)


def get_max_cpu() -&gt; int:
    &#34;&#34;&#34;
    Max available CPU (rounded up if fractional), takes into account pod
    resource allocation
    &#34;&#34;&#34;
    ncpu = get_cpu_quota()
    if ncpu is not None:
        return int(math.ceil(ncpu))
    return psutil.cpu_count()


class PredictFromFeature:
    &#34;&#34;&#34;
    This only covers 2019 case in sandbox now.
    Check configuration in FeaturePathConfig before use run this.
    refer to feature build: https://gist.github.com/cbur24/436a18145c2ac291247360c99ae053be
    &#34;&#34;&#34;

    def __init__(
        self,
        config: Optional[FeaturePathConfig] = None,
        geobox_dict: Optional[Dict] = None,
        client: Optional[Client] = None,
    ):
        self.config = config if config else FeaturePathConfig()
        self.geobox_dict = geobox_dict
        if not client:
            nthreads = get_max_cpu()
            memory_limit = get_max_mem()
            client = start_local_dask(
                threads_per_worker=nthreads,
                processes=False,
                memory_limit=int(0.9 * memory_limit),
            )
            configure_s3_access(aws_unsigned=True, cloud_defaults=True, client=client)
        self.client = client

        setup_logging()
        self._log = logging.getLogger(__name__)

    @staticmethod
    def predict_with_model(config, model, data: xr.Dataset) -&gt; xr.Dataset:
        &#34;&#34;&#34;
        run the prediction here, default crs=&#39;epsg:4326&#39;
        The sample of a feature:
        :return: None
        &#34;&#34;&#34;
        # step 1: select features
        input_data = data[config.training_features]

        # step 2: prediction
        predicted = predict_xr(
            model,
            input_data,
            clean=True,
            proba=True,
        )
        return predicted.persist()

    def save_data(
        self,
        subfld: str,
        predict: xr.DataArray,
        probabilites: xr.DataArray,
        geobox_used: GeoBox,
    ):
        &#34;&#34;&#34;
        save the prediction results to local folder, prepare stac json
        :param subfld: local subfolder to save the prediction tifs`
        :param predict: predicted binary class label array
        :param probabilites: prediction probabilities array
        :param geobox_used: geobox used for the features for prediction
        :return: None
        &#34;&#34;&#34;
        output_fld, paths, metadata_path = prepare_the_io_path(self.config, subfld)
        x, y = get_xy_from_task(subfld)
        if not osp.exists(output_fld):
            os.makedirs(output_fld)

        self._log.info(&#34;collecting mask and write cog.&#34;)
        write_cog(
            predict.astype(np.uint8).compute(),
            paths[&#34;mask&#34;],
            overwrite=True,
        )

        self._log.info(&#34;collecting prob and write cog.&#34;)
        write_cog(
            probabilites.astype(np.uint8).compute(),
            paths[&#34;prob&#34;],
            overwrite=True,
        )

        self._log.info(&#34;collecting the stac json and write out.&#34;)

        processing_dt = datetime.datetime.now()

        uuid_hex = uuid.uuid4()
        remoe_path = dict((k, osp.basename(p)) for k, p in paths.items())
        remote_metadata_path = metadata_path.replace(
            self.config.DATA_PATH, self.config.REMOTE_PATH
        )
        stac_doc = StacIntoDc.render_metadata(
            self.config.product,
            geobox_used,
            (x, y),
            self.config.datetime_range,
            uuid_hex,
            remoe_path,
            remote_metadata_path,
            processing_dt,
        )

        with open(metadata_path, &#34;w&#34;) as fh:
            json.dump(stac_doc, fh, indent=2)


# @click.command(&#34;tile-predict&#34;)
# @click.argument(&#34;task-str&#34;, type=str, nargs=1)
# def main(task_str):
#     worker = PredictFromFeature()
#     worker.run(task_str)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dea_ml.core.predict_from_feature.get_max_cpu"><code class="name flex">
<span>def <span class="ident">get_max_cpu</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Max available CPU (rounded up if fractional), takes into account pod
resource allocation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_cpu() -&gt; int:
    &#34;&#34;&#34;
    Max available CPU (rounded up if fractional), takes into account pod
    resource allocation
    &#34;&#34;&#34;
    ncpu = get_cpu_quota()
    if ncpu is not None:
        return int(math.ceil(ncpu))
    return psutil.cpu_count()</code></pre>
</details>
</dd>
<dt id="dea_ml.core.predict_from_feature.get_max_mem"><code class="name flex">
<span>def <span class="ident">get_max_mem</span></span>(<span>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Max available memory, takes into account pod resource allocation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_mem() -&gt; int:
    &#34;&#34;&#34;
    Max available memory, takes into account pod resource allocation
    &#34;&#34;&#34;
    total = psutil.virtual_memory().total
    mem_quota = get_mem_quota()
    if mem_quota is None:
        return total
    return min(mem_quota, total)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dea_ml.core.predict_from_feature.PredictFromFeature"><code class="flex name class">
<span>class <span class="ident">PredictFromFeature</span></span>
<span>(</span><span>config: Union[<a title="dea_ml.config.product_feature_config.FeaturePathConfig" href="../config/product_feature_config.html#dea_ml.config.product_feature_config.FeaturePathConfig">FeaturePathConfig</a>, NoneType] = None, geobox_dict: Union[Dict, NoneType] = None, client: Union[distributed.client.Client, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This only covers 2019 case in sandbox now.
Check configuration in FeaturePathConfig before use run this.
refer to feature build: <a href="https://gist.github.com/cbur24/436a18145c2ac291247360c99ae053be">https://gist.github.com/cbur24/436a18145c2ac291247360c99ae053be</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PredictFromFeature:
    &#34;&#34;&#34;
    This only covers 2019 case in sandbox now.
    Check configuration in FeaturePathConfig before use run this.
    refer to feature build: https://gist.github.com/cbur24/436a18145c2ac291247360c99ae053be
    &#34;&#34;&#34;

    def __init__(
        self,
        config: Optional[FeaturePathConfig] = None,
        geobox_dict: Optional[Dict] = None,
        client: Optional[Client] = None,
    ):
        self.config = config if config else FeaturePathConfig()
        self.geobox_dict = geobox_dict
        if not client:
            nthreads = get_max_cpu()
            memory_limit = get_max_mem()
            client = start_local_dask(
                threads_per_worker=nthreads,
                processes=False,
                memory_limit=int(0.9 * memory_limit),
            )
            configure_s3_access(aws_unsigned=True, cloud_defaults=True, client=client)
        self.client = client

        setup_logging()
        self._log = logging.getLogger(__name__)

    @staticmethod
    def predict_with_model(config, model, data: xr.Dataset) -&gt; xr.Dataset:
        &#34;&#34;&#34;
        run the prediction here, default crs=&#39;epsg:4326&#39;
        The sample of a feature:
        :return: None
        &#34;&#34;&#34;
        # step 1: select features
        input_data = data[config.training_features]

        # step 2: prediction
        predicted = predict_xr(
            model,
            input_data,
            clean=True,
            proba=True,
        )
        return predicted.persist()

    def save_data(
        self,
        subfld: str,
        predict: xr.DataArray,
        probabilites: xr.DataArray,
        geobox_used: GeoBox,
    ):
        &#34;&#34;&#34;
        save the prediction results to local folder, prepare stac json
        :param subfld: local subfolder to save the prediction tifs`
        :param predict: predicted binary class label array
        :param probabilites: prediction probabilities array
        :param geobox_used: geobox used for the features for prediction
        :return: None
        &#34;&#34;&#34;
        output_fld, paths, metadata_path = prepare_the_io_path(self.config, subfld)
        x, y = get_xy_from_task(subfld)
        if not osp.exists(output_fld):
            os.makedirs(output_fld)

        self._log.info(&#34;collecting mask and write cog.&#34;)
        write_cog(
            predict.astype(np.uint8).compute(),
            paths[&#34;mask&#34;],
            overwrite=True,
        )

        self._log.info(&#34;collecting prob and write cog.&#34;)
        write_cog(
            probabilites.astype(np.uint8).compute(),
            paths[&#34;prob&#34;],
            overwrite=True,
        )

        self._log.info(&#34;collecting the stac json and write out.&#34;)

        processing_dt = datetime.datetime.now()

        uuid_hex = uuid.uuid4()
        remoe_path = dict((k, osp.basename(p)) for k, p in paths.items())
        remote_metadata_path = metadata_path.replace(
            self.config.DATA_PATH, self.config.REMOTE_PATH
        )
        stac_doc = StacIntoDc.render_metadata(
            self.config.product,
            geobox_used,
            (x, y),
            self.config.datetime_range,
            uuid_hex,
            remoe_path,
            remote_metadata_path,
            processing_dt,
        )

        with open(metadata_path, &#34;w&#34;) as fh:
            json.dump(stac_doc, fh, indent=2)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dea_ml.core.predict_from_feature.PredictFromFeature.predict_with_model"><code class="name flex">
<span>def <span class="ident">predict_with_model</span></span>(<span>config, model, data: xarray.core.dataset.Dataset) ‑> xarray.core.dataset.Dataset</span>
</code></dt>
<dd>
<div class="desc"><p>run the prediction here, default crs='epsg:4326'
The sample of a feature:
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def predict_with_model(config, model, data: xr.Dataset) -&gt; xr.Dataset:
    &#34;&#34;&#34;
    run the prediction here, default crs=&#39;epsg:4326&#39;
    The sample of a feature:
    :return: None
    &#34;&#34;&#34;
    # step 1: select features
    input_data = data[config.training_features]

    # step 2: prediction
    predicted = predict_xr(
        model,
        input_data,
        clean=True,
        proba=True,
    )
    return predicted.persist()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dea_ml.core.predict_from_feature.PredictFromFeature.save_data"><code class="name flex">
<span>def <span class="ident">save_data</span></span>(<span>self, subfld: str, predict: xarray.core.dataarray.DataArray, probabilites: xarray.core.dataarray.DataArray, geobox_used: datacube.utils.geometry._base.GeoBox)</span>
</code></dt>
<dd>
<div class="desc"><p>save the prediction results to local folder, prepare stac json
:param subfld: local subfolder to save the prediction tifs`
:param predict: predicted binary class label array
:param probabilites: prediction probabilities array
:param geobox_used: geobox used for the features for prediction
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_data(
    self,
    subfld: str,
    predict: xr.DataArray,
    probabilites: xr.DataArray,
    geobox_used: GeoBox,
):
    &#34;&#34;&#34;
    save the prediction results to local folder, prepare stac json
    :param subfld: local subfolder to save the prediction tifs`
    :param predict: predicted binary class label array
    :param probabilites: prediction probabilities array
    :param geobox_used: geobox used for the features for prediction
    :return: None
    &#34;&#34;&#34;
    output_fld, paths, metadata_path = prepare_the_io_path(self.config, subfld)
    x, y = get_xy_from_task(subfld)
    if not osp.exists(output_fld):
        os.makedirs(output_fld)

    self._log.info(&#34;collecting mask and write cog.&#34;)
    write_cog(
        predict.astype(np.uint8).compute(),
        paths[&#34;mask&#34;],
        overwrite=True,
    )

    self._log.info(&#34;collecting prob and write cog.&#34;)
    write_cog(
        probabilites.astype(np.uint8).compute(),
        paths[&#34;prob&#34;],
        overwrite=True,
    )

    self._log.info(&#34;collecting the stac json and write out.&#34;)

    processing_dt = datetime.datetime.now()

    uuid_hex = uuid.uuid4()
    remoe_path = dict((k, osp.basename(p)) for k, p in paths.items())
    remote_metadata_path = metadata_path.replace(
        self.config.DATA_PATH, self.config.REMOTE_PATH
    )
    stac_doc = StacIntoDc.render_metadata(
        self.config.product,
        geobox_used,
        (x, y),
        self.config.datetime_range,
        uuid_hex,
        remoe_path,
        remote_metadata_path,
        processing_dt,
    )

    with open(metadata_path, &#34;w&#34;) as fh:
        json.dump(stac_doc, fh, indent=2)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dea_ml.core" href="index.html">dea_ml.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dea_ml.core.predict_from_feature.get_max_cpu" href="#dea_ml.core.predict_from_feature.get_max_cpu">get_max_cpu</a></code></li>
<li><code><a title="dea_ml.core.predict_from_feature.get_max_mem" href="#dea_ml.core.predict_from_feature.get_max_mem">get_max_mem</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dea_ml.core.predict_from_feature.PredictFromFeature" href="#dea_ml.core.predict_from_feature.PredictFromFeature">PredictFromFeature</a></code></h4>
<ul class="">
<li><code><a title="dea_ml.core.predict_from_feature.PredictFromFeature.predict_with_model" href="#dea_ml.core.predict_from_feature.PredictFromFeature.predict_with_model">predict_with_model</a></code></li>
<li><code><a title="dea_ml.core.predict_from_feature.PredictFromFeature.save_data" href="#dea_ml.core.predict_from_feature.PredictFromFeature.save_data">save_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>