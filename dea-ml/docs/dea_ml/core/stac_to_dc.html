<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dea_ml.core.stac_to_dc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dea_ml.core.stac_to_dc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
from collections.abc import Callable
from copy import deepcopy
from datetime import datetime, timezone
from typing import Optional, Dict, Any, Tuple, List
from uuid import UUID

import pystac
from datacube import Datacube
from datacube.model import Dataset, DatasetType
from datacube.utils import changes
from datacube.utils.geometry import GeoBox
from odc.index.stac import stac_transform
from odc.stats.model import (
    format_datetime,
    OutputProduct,
    TileIdx_xy,
    DateTimeRange,
)


class StacIntoDc:
    &#34;&#34;&#34;
    use the method in odc-stas s3-to-dc
    copy from dc_tools for testing purposes only
    stac json do  stac_transform into the EO3
    from_metadata_stream into dataset
    process the prediction results into datacube. Generalized to all ad hoc products into indexing
    1. generate the metadata stac format json into s3 or local
    2. upload the predicttion tifs onto s3 allow with stac json but with band names [&#39;MASK&#39;, &#39;PROB&#39;]
    3. add or update index into datacube
    &#34;&#34;&#34;

    @staticmethod
    def index_update_dataset(
        dc: Datacube, datasets: Tuple[dict, str], update: bool, allow_unsafe: bool
    ) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        copy from dc_tools for testing purposes only
        stac json do  stac_transform into the EO3
        from_metadata_stream into dataset
        @param dc:
        @param datasets: dataset, uri as in the for loop below, dataset: datacube.model.Dataset
        @param update:
        @param allow_unsafe:
        @return:
        &#34;&#34;&#34;
        ds_added = 0
        ds_failed = 0

        for dataset, uri in datasets:
            # datacube.model.Dataset
            if uri is not None:
                if dataset is not None:
                    if update:
                        updates: Dict[Tuple, Any] = {}
                        if allow_unsafe:
                            updates = {tuple(): changes.allow_any}
                        dc.index.datasets.update(dataset, updates_allowed=updates)
                    else:
                        ds_added += 1
                        dc.index.datasets.add(dataset)
                else:
                    ds_failed += 1
            else:
                ds_failed += 1

        return ds_added, ds_failed

    @staticmethod
    def to_dc_dataset(
        dc: Datacube,
        rendered: Dict[str, Any],
        ds_type: Optional[DatasetType] = None,
        transform: Callable = stac_transform,
        product_name: str = &#34;crop_mask&#34;,
    ) -&gt; Dataset:
        &#34;&#34;&#34; &#34;
        Stac transformed
        &#34;&#34;&#34;
        if not ds_type:
            ds_type = dict((d.name, d) for d in dc.index.datasets.types.get_all())[
                product_name
            ]
        return Dataset(ds_type, transform(rendered))

    @staticmethod
    def render_metadata(
        product: OutputProduct,
        geobox: GeoBox,
        tile_index: TileIdx_xy,
        time_range: DateTimeRange,
        uuid: UUID,
        paths: Dict[str, str],
        metadata_path: str,
        processing_dt: Optional[datetime] = None,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Put together STAC metadata document for the output from the task info.
        &#34;&#34;&#34;
        if processing_dt is None:
            processing_dt = datetime.utcnow()

        region_code = product.region_code(tile_index)
        inputs: List[str] = []

        properties: Dict[str, Any] = deepcopy(product.properties)
        properties[&#34;dtr:start_datetime&#34;] = format_datetime(time_range.start)
        properties[&#34;dtr:end_datetime&#34;] = format_datetime(time_range.end)
        properties[&#34;odc:processing_datetime&#34;] = format_datetime(
            processing_dt, timespec=&#34;seconds&#34;
        )
        properties[&#34;odc:region_code&#34;] = region_code
        properties[&#34;odc:lineage&#34;] = dict(inputs=inputs)
        properties[&#34;odc:product&#34;] = product.name

        geobox_wgs84 = geobox.extent.to_crs(
            &#34;epsg:4326&#34;, resolution=math.inf, wrapdateline=True
        )
        bbox = geobox_wgs84.boundingbox

        item = pystac.Item(
            id=str(uuid),
            geometry=geobox_wgs84.json,
            bbox=[bbox.left, bbox.bottom, bbox.right, bbox.top],
            datetime=time_range.start.replace(tzinfo=timezone.utc),
            properties=properties,
        )

        # Enable the Projection extension
        item.ext.enable(&#34;projection&#34;)
        item.ext.projection.epsg = geobox.crs.epsg

        # Add all the assets
        for band, path in paths.items():
            asset = pystac.Asset(
                href=path,
                media_type=&#34;image/tiff; application=geotiff&#34;,
                roles=[&#34;data&#34;],
                title=band,
            )
            item.add_asset(band, asset)

            item.ext.projection.set_transform(geobox.transform, asset=asset)
            item.ext.projection.set_shape(geobox.shape, asset=asset)

        # Add links
        item.links.append(
            pystac.Link(
                rel=&#34;product_overview&#34;,
                media_type=&#34;application/json&#34;,
                target=product.href,
            )
        )
        item.links.append(
            pystac.Link(
                rel=&#34;self&#34;,
                media_type=&#34;application/json&#34;,
                target=metadata_path,
            )
        )

        return item.to_dict()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dea_ml.core.stac_to_dc.StacIntoDc"><code class="flex name class">
<span>class <span class="ident">StacIntoDc</span></span>
</code></dt>
<dd>
<div class="desc"><p>use the method in odc-stas s3-to-dc
copy from dc_tools for testing purposes only
stac json do
stac_transform into the EO3
from_metadata_stream into dataset
process the prediction results into datacube. Generalized to all ad hoc products into indexing
1. generate the metadata stac format json into s3 or local
2. upload the predicttion tifs onto s3 allow with stac json but with band names ['MASK', 'PROB']
3. add or update index into datacube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StacIntoDc:
    &#34;&#34;&#34;
    use the method in odc-stas s3-to-dc
    copy from dc_tools for testing purposes only
    stac json do  stac_transform into the EO3
    from_metadata_stream into dataset
    process the prediction results into datacube. Generalized to all ad hoc products into indexing
    1. generate the metadata stac format json into s3 or local
    2. upload the predicttion tifs onto s3 allow with stac json but with band names [&#39;MASK&#39;, &#39;PROB&#39;]
    3. add or update index into datacube
    &#34;&#34;&#34;

    @staticmethod
    def index_update_dataset(
        dc: Datacube, datasets: Tuple[dict, str], update: bool, allow_unsafe: bool
    ) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        copy from dc_tools for testing purposes only
        stac json do  stac_transform into the EO3
        from_metadata_stream into dataset
        @param dc:
        @param datasets: dataset, uri as in the for loop below, dataset: datacube.model.Dataset
        @param update:
        @param allow_unsafe:
        @return:
        &#34;&#34;&#34;
        ds_added = 0
        ds_failed = 0

        for dataset, uri in datasets:
            # datacube.model.Dataset
            if uri is not None:
                if dataset is not None:
                    if update:
                        updates: Dict[Tuple, Any] = {}
                        if allow_unsafe:
                            updates = {tuple(): changes.allow_any}
                        dc.index.datasets.update(dataset, updates_allowed=updates)
                    else:
                        ds_added += 1
                        dc.index.datasets.add(dataset)
                else:
                    ds_failed += 1
            else:
                ds_failed += 1

        return ds_added, ds_failed

    @staticmethod
    def to_dc_dataset(
        dc: Datacube,
        rendered: Dict[str, Any],
        ds_type: Optional[DatasetType] = None,
        transform: Callable = stac_transform,
        product_name: str = &#34;crop_mask&#34;,
    ) -&gt; Dataset:
        &#34;&#34;&#34; &#34;
        Stac transformed
        &#34;&#34;&#34;
        if not ds_type:
            ds_type = dict((d.name, d) for d in dc.index.datasets.types.get_all())[
                product_name
            ]
        return Dataset(ds_type, transform(rendered))

    @staticmethod
    def render_metadata(
        product: OutputProduct,
        geobox: GeoBox,
        tile_index: TileIdx_xy,
        time_range: DateTimeRange,
        uuid: UUID,
        paths: Dict[str, str],
        metadata_path: str,
        processing_dt: Optional[datetime] = None,
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Put together STAC metadata document for the output from the task info.
        &#34;&#34;&#34;
        if processing_dt is None:
            processing_dt = datetime.utcnow()

        region_code = product.region_code(tile_index)
        inputs: List[str] = []

        properties: Dict[str, Any] = deepcopy(product.properties)
        properties[&#34;dtr:start_datetime&#34;] = format_datetime(time_range.start)
        properties[&#34;dtr:end_datetime&#34;] = format_datetime(time_range.end)
        properties[&#34;odc:processing_datetime&#34;] = format_datetime(
            processing_dt, timespec=&#34;seconds&#34;
        )
        properties[&#34;odc:region_code&#34;] = region_code
        properties[&#34;odc:lineage&#34;] = dict(inputs=inputs)
        properties[&#34;odc:product&#34;] = product.name

        geobox_wgs84 = geobox.extent.to_crs(
            &#34;epsg:4326&#34;, resolution=math.inf, wrapdateline=True
        )
        bbox = geobox_wgs84.boundingbox

        item = pystac.Item(
            id=str(uuid),
            geometry=geobox_wgs84.json,
            bbox=[bbox.left, bbox.bottom, bbox.right, bbox.top],
            datetime=time_range.start.replace(tzinfo=timezone.utc),
            properties=properties,
        )

        # Enable the Projection extension
        item.ext.enable(&#34;projection&#34;)
        item.ext.projection.epsg = geobox.crs.epsg

        # Add all the assets
        for band, path in paths.items():
            asset = pystac.Asset(
                href=path,
                media_type=&#34;image/tiff; application=geotiff&#34;,
                roles=[&#34;data&#34;],
                title=band,
            )
            item.add_asset(band, asset)

            item.ext.projection.set_transform(geobox.transform, asset=asset)
            item.ext.projection.set_shape(geobox.shape, asset=asset)

        # Add links
        item.links.append(
            pystac.Link(
                rel=&#34;product_overview&#34;,
                media_type=&#34;application/json&#34;,
                target=product.href,
            )
        )
        item.links.append(
            pystac.Link(
                rel=&#34;self&#34;,
                media_type=&#34;application/json&#34;,
                target=metadata_path,
            )
        )

        return item.to_dict()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dea_ml.core.stac_to_dc.StacIntoDc.index_update_dataset"><code class="name flex">
<span>def <span class="ident">index_update_dataset</span></span>(<span>dc: datacube.api.core.Datacube, datasets: Tuple[dict, str], update: bool, allow_unsafe: bool) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>copy from dc_tools for testing purposes only
stac json do
stac_transform into the EO3
from_metadata_stream into dataset
@param dc:
@param datasets: dataset, uri as in the for loop below, dataset: datacube.model.Dataset
@param update:
@param allow_unsafe:
@return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def index_update_dataset(
    dc: Datacube, datasets: Tuple[dict, str], update: bool, allow_unsafe: bool
) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    copy from dc_tools for testing purposes only
    stac json do  stac_transform into the EO3
    from_metadata_stream into dataset
    @param dc:
    @param datasets: dataset, uri as in the for loop below, dataset: datacube.model.Dataset
    @param update:
    @param allow_unsafe:
    @return:
    &#34;&#34;&#34;
    ds_added = 0
    ds_failed = 0

    for dataset, uri in datasets:
        # datacube.model.Dataset
        if uri is not None:
            if dataset is not None:
                if update:
                    updates: Dict[Tuple, Any] = {}
                    if allow_unsafe:
                        updates = {tuple(): changes.allow_any}
                    dc.index.datasets.update(dataset, updates_allowed=updates)
                else:
                    ds_added += 1
                    dc.index.datasets.add(dataset)
            else:
                ds_failed += 1
        else:
            ds_failed += 1

    return ds_added, ds_failed</code></pre>
</details>
</dd>
<dt id="dea_ml.core.stac_to_dc.StacIntoDc.render_metadata"><code class="name flex">
<span>def <span class="ident">render_metadata</span></span>(<span>product: odc.stats.model.OutputProduct, geobox: datacube.utils.geometry._base.GeoBox, tile_index: Tuple[int, int], time_range: odc.stats.model.DateTimeRange, uuid: uuid.UUID, paths: Dict[str, str], metadata_path: str, processing_dt: Union[datetime.datetime, NoneType] = None) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Put together STAC metadata document for the output from the task info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def render_metadata(
    product: OutputProduct,
    geobox: GeoBox,
    tile_index: TileIdx_xy,
    time_range: DateTimeRange,
    uuid: UUID,
    paths: Dict[str, str],
    metadata_path: str,
    processing_dt: Optional[datetime] = None,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Put together STAC metadata document for the output from the task info.
    &#34;&#34;&#34;
    if processing_dt is None:
        processing_dt = datetime.utcnow()

    region_code = product.region_code(tile_index)
    inputs: List[str] = []

    properties: Dict[str, Any] = deepcopy(product.properties)
    properties[&#34;dtr:start_datetime&#34;] = format_datetime(time_range.start)
    properties[&#34;dtr:end_datetime&#34;] = format_datetime(time_range.end)
    properties[&#34;odc:processing_datetime&#34;] = format_datetime(
        processing_dt, timespec=&#34;seconds&#34;
    )
    properties[&#34;odc:region_code&#34;] = region_code
    properties[&#34;odc:lineage&#34;] = dict(inputs=inputs)
    properties[&#34;odc:product&#34;] = product.name

    geobox_wgs84 = geobox.extent.to_crs(
        &#34;epsg:4326&#34;, resolution=math.inf, wrapdateline=True
    )
    bbox = geobox_wgs84.boundingbox

    item = pystac.Item(
        id=str(uuid),
        geometry=geobox_wgs84.json,
        bbox=[bbox.left, bbox.bottom, bbox.right, bbox.top],
        datetime=time_range.start.replace(tzinfo=timezone.utc),
        properties=properties,
    )

    # Enable the Projection extension
    item.ext.enable(&#34;projection&#34;)
    item.ext.projection.epsg = geobox.crs.epsg

    # Add all the assets
    for band, path in paths.items():
        asset = pystac.Asset(
            href=path,
            media_type=&#34;image/tiff; application=geotiff&#34;,
            roles=[&#34;data&#34;],
            title=band,
        )
        item.add_asset(band, asset)

        item.ext.projection.set_transform(geobox.transform, asset=asset)
        item.ext.projection.set_shape(geobox.shape, asset=asset)

    # Add links
    item.links.append(
        pystac.Link(
            rel=&#34;product_overview&#34;,
            media_type=&#34;application/json&#34;,
            target=product.href,
        )
    )
    item.links.append(
        pystac.Link(
            rel=&#34;self&#34;,
            media_type=&#34;application/json&#34;,
            target=metadata_path,
        )
    )

    return item.to_dict()</code></pre>
</details>
</dd>
<dt id="dea_ml.core.stac_to_dc.StacIntoDc.to_dc_dataset"><code class="name flex">
<span>def <span class="ident">to_dc_dataset</span></span>(<span>dc: datacube.api.core.Datacube, rendered: Dict[str, Any], ds_type: Union[datacube.model.DatasetType, NoneType] = None, transform: collections.abc.Callable = &lt;function stac_transform&gt;, product_name: str = 'crop_mask') ‑> datacube.model.Dataset</span>
</code></dt>
<dd>
<div class="desc"><p>"
Stac transformed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_dc_dataset(
    dc: Datacube,
    rendered: Dict[str, Any],
    ds_type: Optional[DatasetType] = None,
    transform: Callable = stac_transform,
    product_name: str = &#34;crop_mask&#34;,
) -&gt; Dataset:
    &#34;&#34;&#34; &#34;
    Stac transformed
    &#34;&#34;&#34;
    if not ds_type:
        ds_type = dict((d.name, d) for d in dc.index.datasets.types.get_all())[
            product_name
        ]
    return Dataset(ds_type, transform(rendered))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dea_ml.core" href="index.html">dea_ml.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dea_ml.core.stac_to_dc.StacIntoDc" href="#dea_ml.core.stac_to_dc.StacIntoDc">StacIntoDc</a></code></h4>
<ul class="">
<li><code><a title="dea_ml.core.stac_to_dc.StacIntoDc.index_update_dataset" href="#dea_ml.core.stac_to_dc.StacIntoDc.index_update_dataset">index_update_dataset</a></code></li>
<li><code><a title="dea_ml.core.stac_to_dc.StacIntoDc.render_metadata" href="#dea_ml.core.stac_to_dc.StacIntoDc.render_metadata">render_metadata</a></code></li>
<li><code><a title="dea_ml.core.stac_to_dc.StacIntoDc.to_dc_dataset" href="#dea_ml.core.stac_to_dc.StacIntoDc.to_dc_dataset">to_dc_dataset</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>